<story-context id="3.5-reading-recommendations" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>5</storyId>
    <title>AI-Powered Reading Recommendations</title>
    <status>drafted</status>
    <generatedAt>2025-12-08</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/3.5-reading-recommendations.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>knowledge base user querying via Claude Desktop</asA>
    <iWant>receive AI-powered reading recommendations based on my recent reads and top interest clusters</iWant>
    <soThat>I can discover high-quality, relevant articles to continue learning about topics I care about without manually searching the web</soThat>
    <tasks>
      <task id="1" ac="2,9">Set up Tavily API integration - API key in Secret Manager, create tavily_client.py with search method</task>
      <task id="2" ac="3">Implement domain whitelist configuration - Firestore config/recommendation_domains, CRUD in firestore_client.py</task>
      <task id="3" ac="4">Implement smart query generation - recommendation_queries.py with theme extraction from recent reads and clusters</task>
      <task id="4" ac="5,7">Implement quality filtering - recommendation_filter.py with Gemini depth scoring, diversity cap</task>
      <task id="5" ac="6">Implement KB deduplication - embed recommendation, check similarity against existing chunks (threshold 0.85)</task>
      <task id="6" ac="1,8">Implement main MCP tool - get_reading_recommendations() in tools.py, register in main.py</task>
      <task id="7" ac="1-9">Testing and validation - unit tests, integration tests, manual Claude Desktop validation</task>
      <task id="8" ac="1">Documentation - update mcp-server-usage.md with new tools</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <ac id="1">MCP tool functional: get_reading_recommendations(scope, days, limit) returns personalized article recommendations</ac>
    <ac id="2">Tavily Search API integration: Tool queries Tavily with domain filtering (include_domains) and recency constraints (days parameter)</ac>
    <ac id="3">Dynamic domain whitelist: Configuration stored in Firestore config/recommendation_domains with quality_domains and excluded_domains</ac>
    <ac id="4">Smart query generation: Generates search queries from KB context - cluster names, knowledge card takeaways, gap detection</ac>
    <ac id="5">Quality filtering via Gemini: Each result scored (depth 1-5, require 3+), generates "why recommended" explanation</ac>
    <ac id="6">Deduplication against KB: Embeds recommendation, checks similarity (threshold 0.85), skips duplicates</ac>
    <ac id="7">Source diversity: Maximum 2 recommendations per domain</ac>
    <ac id="8">Performance: Tool responds in less than 60 seconds</ac>
    <ac id="9">Cost efficiency: Uses Tavily free tier + minimal Gemini calls, target less than $0.10/month</ac>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="docs/mcp-server-usage.md" title="MCP Server Usage Guide" section="Available Tools" snippet="Comprehensive documentation of existing MCP tools including search_semantic, list_clusters, get_related_clusters. Pattern for tool documentation." />
      <doc path="docs/architecture.md" title="Architecture" section="MCP Integration" snippet="MCP server architecture, query flow via Claude Desktop, Firestore native vector search with FIND_NEAREST." />
      <doc path="docs/stories/3.4-cluster-relationship-discovery.md" title="Story 3.4" section="Dev Agent Record" snippet="Previous story implementation patterns - tool registration in main.py lines 361-382 (schema), 464-468 (handler). Use get_firestore_client() not get_db()." />
      <doc path="docs/epics.md" title="Epics" section="Story 3.5" snippet="Full story requirements including Tavily integration, domain whitelist, smart query generation, quality filtering approach." />
    </docs>
    <code>
      <file path="src/mcp_server/tools.py" kind="tool-handlers" symbol="_format_urls, _format_knowledge_card, search_semantic, get_related_clusters" lines="1-150, 1040-1152" reason="Existing MCP tool implementations - pattern for new get_reading_recommendations()" />
      <file path="src/mcp_server/main.py" kind="mcp-server" symbol="call_tool_handler, list_tools_handler" lines="350-485" reason="Tool registration pattern - schema in list_tools, handler in call_tool switch" />
      <file path="src/mcp_server/firestore_client.py" kind="data-access" symbol="get_firestore_client, get_all_clusters, get_activity_summary, find_nearest" lines="1-732" reason="Firestore access patterns - will need to add get_recommendation_config(), update_recommendation_config()" />
      <file path="src/mcp_server/embeddings.py" kind="embeddings" symbol="generate_query_embedding" lines="53-114" reason="Embedding generation for deduplication check - reuse for recommendation title+snippet embedding" />
      <file path="tests/test_cluster_relationships.py" kind="test" reason="Testing pattern for MCP tools with mocked Firestore" />
      <file path="tests/test_mcp_tools.py" kind="test" reason="MCP tool unit test patterns" />
    </code>
    <dependencies>
      <python>
        <package name="google-cloud-firestore" version="*" />
        <package name="google-cloud-aiplatform" version="*" />
        <package name="vertexai" version="*" />
        <package name="mcp" version="*" />
        <package name="tavily-python" version="*" note="NEW - to be added for Tavily API" />
      </python>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="pattern">Follow existing MCP tool pattern: function in tools.py, schema in list_tools handler (main.py), handler in call_tool switch (main.py)</constraint>
    <constraint type="api">Use get_firestore_client() not get_db() for Firestore access</constraint>
    <constraint type="cost">Tavily free tier: 1000 queries/month. Target &lt;$0.10/month additional cost</constraint>
    <constraint type="performance">Tool must respond in &lt;60 seconds total processing time</constraint>
    <constraint type="secrets">Store Tavily API key in Google Secret Manager at /kx-hub/tavily/api-key</constraint>
    <constraint type="config">Store domain whitelist in Firestore config/recommendation_domains document</constraint>
    <constraint type="quality">Require depth score 3+ (scale 1-5) for recommendations. Max 2 per domain for diversity.</constraint>
    <constraint type="dedup">Similarity threshold 0.85 for KB deduplication using embedding comparison</constraint>
  </constraints>

  <interfaces>
    <interface name="get_reading_recommendations" kind="mcp-tool" path="src/mcp_server/tools.py">
      <signature>def get_reading_recommendations(scope: str = "both", days: int = 14, limit: int = 10) -> Dict[str, Any]</signature>
      <params>
        <param name="scope" type="str" default="both" desc="recent | clusters | both" />
        <param name="days" type="int" default="14" desc="Lookback period for recent reads" />
        <param name="limit" type="int" default="10" desc="Maximum recommendations" />
      </params>
      <returns>Dict with generated_at, processing_time_seconds, scope, recommendations list, filtered_out counts</returns>
    </interface>
    <interface name="update_recommendation_domains" kind="mcp-tool" path="src/mcp_server/tools.py">
      <signature>def update_recommendation_domains(add_domains: List[str] = None, remove_domains: List[str] = None) -> Dict[str, Any]</signature>
      <params>
        <param name="add_domains" type="List[str]" default="None" desc="Domains to add to whitelist" />
        <param name="remove_domains" type="List[str]" default="None" desc="Domains to remove from whitelist" />
      </params>
      <returns>Dict with updated domain list and confirmation</returns>
    </interface>
    <interface name="Tavily Search API" kind="external-api" path="https://api.tavily.com/search">
      <signature>POST /search with query, include_domains, days parameters</signature>
      <returns>JSON with results array containing title, url, content, published_date</returns>
    </interface>
    <interface name="Gemini 2.0 Flash" kind="vertex-ai" path="Vertex AI">
      <signature>vertexai.generative_models.GenerativeModel("gemini-2.0-flash-001")</signature>
      <returns>Quality score (1-5) and "why recommended" explanation</returns>
    </interface>
  </interfaces>

  <tests>
    <standards>Unit tests with mocked external APIs (Tavily, Gemini, Firestore). Integration tests for end-to-end flow. Tests located in tests/ folder following test_*.py pattern. Use pytest framework.</standards>
    <locations>
      <loc>tests/test_recommendations.py (NEW)</loc>
      <loc>tests/test_tavily_client.py (NEW)</loc>
    </locations>
    <ideas>
      <idea ac="1">Test get_reading_recommendations() returns valid structure with recommendations</idea>
      <idea ac="2">Test Tavily client search() with mocked API, test error handling and retry logic</idea>
      <idea ac="3">Test get_recommendation_config() returns domain lists, test update_recommendation_config() modifies Firestore</idea>
      <idea ac="4">Test query generation from cluster themes and knowledge card takeaways</idea>
      <idea ac="5">Test Gemini quality scoring returns 1-5 scale, test filtering at threshold 3</idea>
      <idea ac="6">Test deduplication detects existing KB content with similarity &gt; 0.85</idea>
      <idea ac="7">Test source diversity cap limits to 2 per domain</idea>
      <idea ac="8">Test total processing time &lt; 60 seconds (may require mocking for unit tests)</idea>
      <idea ac="9">Integration test verifies Tavily free tier usage</idea>
    </ideas>
  </tests>
</story-context>
