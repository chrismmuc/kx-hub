# Story 2.4: Knowledge Cards Consistency Check

## Status: PLANNED
**Epic:** 2 - AI-Powered Knowledge Processing
**Dependencies:** Story 2.1 (Knowledge Cards), Story 2.3 (Clustering Consistency)
**Priority:** MEDIUM (Quality assurance)

---

## Problem Statement

Following the discovery of inconsistencies between initial clustering and delta clustering (Story 2.3), we need to verify that **Knowledge Cards generation** doesn't suffer from similar issues.

### Questions to Answer

1. **Is the AI prompt identical** for initial load vs delta processing?
2. **Are the same Gemini models used** (e.g., gemini-2.0-flash vs gemini-2.5-flash)?
3. **Is there code duplication** between initial script and Cloud Function?
4. **Are there any parameter differences** that could cause inconsistent card generation?

---

## Investigation Checklist

### 1. Compare Initial Load vs Cloud Function

**Files to review:**
- `src/knowledge_cards/main.py` - Initial bulk generation
- `functions/knowledge_cards/main.py` - Delta generation (if exists)
- OR check if they share code from `src/knowledge_cards/generator.py`

**Aspects to check:**
- [ ] AI prompt template
- [ ] Gemini model version
- [ ] Temperature/top_p parameters
- [ ] Max token limits
- [ ] Retry logic
- [ ] Error handling

### 2. Verify Code Reuse

**Expected pattern:**
```python
# src/knowledge_cards/generator.py (shared module)
class KnowledgeCardGenerator:
    def generate_card(self, chunk):
        # Single implementation used by both initial and delta
        ...

# Initial load uses it
from knowledge_cards.generator import KnowledgeCardGenerator

# Cloud Function also uses it (no duplication)
from knowledge_cards.generator import KnowledgeCardGenerator
```

**Red flags (code duplication):**
- Different prompt strings in different files
- Different model initialization
- Hardcoded parameters in multiple places

### 3. Check Deployment Status

- [ ] When was Knowledge Cards Cloud Function last deployed?
- [ ] Does it include latest generator code?
- [ ] Are environment variables consistent?

---

## Expected Findings

### Scenario A: Already Consistent ✅

If Knowledge Cards were implemented correctly from the start:
- Shared `KnowledgeCardGenerator` class
- Single prompt template
- Consistent parameters
- **Action:** Document the pattern, close story

### Scenario B: Inconsistencies Found ❌

Similar to clustering issue:
- Initial load has updated logic
- Cloud Function uses old implementation
- **Action:** Refactor to shared module (like Story 2.3)

---

## Remediation Plan (if needed)

### Step 1: Create Shared Module

```python
# src/knowledge_cards/generator.py
class KnowledgeCardGenerator:
    """Shared knowledge card generator used by initial load and Cloud Function."""

    def __init__(self, model_name: str = "gemini-2.5-flash"):
        self.model_name = model_name
        self.prompt_template = """..."""  # Single source of truth

    def generate_card(self, chunk: Dict) -> Dict:
        """Generate knowledge card for chunk."""
        # Implementation here
        ...
```

### Step 2: Update Initial Load

```python
# src/knowledge_cards/main.py
from knowledge_cards.generator import KnowledgeCardGenerator

generator = KnowledgeCardGenerator()
card = generator.generate_card(chunk)
```

### Step 3: Update Cloud Function

```python
# functions/knowledge_cards/main.py
from knowledge_cards.generator import KnowledgeCardGenerator

generator = KnowledgeCardGenerator()
card = generator.generate_card(chunk)
```

### Step 4: Deploy

```bash
cd terraform
terraform apply  # Redeploy Cloud Function with shared code
```

---

## Testing

### Consistency Test

```python
def test_initial_and_delta_generate_same_cards():
    """Verify initial and delta use same generation logic."""
    from src.knowledge_cards.main import generate_card as initial_generate
    from functions.knowledge_cards.main import generate_card as delta_generate

    test_chunk = {...}

    # Generate via both paths
    initial_card = initial_generate(test_chunk)
    delta_card = delta_generate(test_chunk)

    # Should be identical (allowing for AI non-determinism with temp=0)
    assert initial_card['title'] == delta_card['title']
    assert initial_card['summary'] == delta_card['summary']
```

### Prompt Stability Test

```python
def test_prompt_template_unchanged():
    """Verify prompt template is consistent."""
    generator = KnowledgeCardGenerator()

    # Check prompt doesn't change between runs
    assert generator.prompt_template == EXPECTED_PROMPT
```

---

## Acceptance Criteria

- [ ] Initial load and Cloud Function code paths analyzed
- [ ] Any inconsistencies documented
- [ ] If found: Shared module created
- [ ] If found: Both paths use shared module
- [ ] If found: Cloud Function redeployed
- [ ] Integration tests verify consistency
- [ ] Documentation updated with findings

---

## Investigation Timeline

**Phase 1 (30 min):** Code review
- Compare initial_load vs Cloud Function
- Check for shared modules
- Document differences

**Phase 2 (1 hour, if needed):** Refactoring
- Extract shared logic
- Update both paths
- Write tests

**Phase 3 (30 min, if needed):** Deployment
- Redeploy Cloud Function
- Verify in production
- Update documentation

---

## Risk Assessment

### Low Risk: Already Consistent

**Likelihood:** Medium (Knowledge Cards were implemented after clustering, may have learned from mistakes)

**If true:**
- No work needed
- Document the good pattern
- Use as reference for future features

### Medium Risk: Minor Inconsistencies

**Likelihood:** High (common in iterative development)

**Examples:**
- Different temperature settings
- Different max_tokens
- Minor prompt variations

**Impact:** Card quality varies slightly between initial and delta

### High Risk: Major Inconsistencies

**Likelihood:** Low

**Examples:**
- Different Gemini models
- Completely different prompts
- Missing features in one path

**Impact:** Significantly different card quality, user confusion

---

## Deliverables

1. **Analysis Report**: Document findings from code review
2. **Refactored Code** (if needed): Shared module implementation
3. **Tests**: Consistency verification tests
4. **Documentation**: Updated architecture docs

---

## Related Stories

- **Story 2.1**: Original Knowledge Cards implementation
- **Story 2.3**: Clustering consistency fix (pattern to follow)
- **Story 2.5**: Graph regeneration (similar deployment concerns)

---

**Story 2.4 prepared for investigation**
**Start with code review to determine scope**
