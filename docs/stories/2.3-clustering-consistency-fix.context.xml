<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>2.3</storyId>
    <title>Clustering Consistency Fix</title>
    <status>drafted</status>
    <generatedAt>2025-11-03</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/2.3-clustering-consistency-fix.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>knowledge base user</asA>
    <iWant>initial clustering and delta clustering to use the same UMAP-reduced embedding space consistently</iWant>
    <soThat>new chunks are assigned to clusters with the same accuracy as initial clustering, preventing cluster quality degradation over time</soThat>
    <tasks>
- Task 1: Implement UMAP model persistence (AC: #1)
- Task 2: Update cluster metadata schema (AC: #2)
- Task 3: Implement transform_and_assign method (AC: #3, #4)
- Task 4: Update Cloud Function for UMAP consistency (AC: #4, #7)
- Task 5: Re-cluster all chunks with new approach (AC: #5)
- Task 6: Testing and validation (AC: #6, #7)
- Task 7: Documentation (AC: #8, #9)
    </tasks>
  </story>

  <acceptanceCriteria>
1. UMAP model saved to Cloud Storage (`gs://kx-hub-pipeline/models/umap_model.pkl`) after initial clustering
2. Cluster centroids stored in both 768D (reference) and 5D (active UMAP-reduced) in Firestore clusters collection
3. `transform_and_assign()` method implemented in `SemanticClusterer` class
4. Cloud Function uses UMAP transform for new chunks (not raw 768D embeddings)
5. All 823 chunks re-clustered using new 5D centroid approach
6. Integration tests verify UMAP consistency between initial clustering and delta processing
7. Delta processing completes in <5 seconds (faster than previous 768D cosine approach)
8. No code duplication between initial load and Cloud Function (shared clustering module used)
9. Documentation updated with UMAP model storage architecture and consistency approach
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic 2 - Enhanced Knowledge Graph & Clustering</title>
        <section>Story 2.3: Clustering Consistency Fix</section>
        <snippet>Fix inconsistency between initial UMAP-based clustering and delta centroid-based assignment by implementing unified UMAP transform for both processes. Store UMAP model in Cloud Storage and use 5D UMAP-reduced centroids.</snippet>
      </doc>
      <doc>
        <path>docs/stories/2.2-semantic-clustering.md</path>
        <title>Story 2.2: Semantic Clustering</title>
        <section>Dev Notes - UMAP Implementation</section>
        <snippet>Implemented UMAP (768D → 5D) + HDBSCAN for initial clustering. Parameters: n_components=5, metric='cosine', min_dist=0.0. Result: 38 clusters from 823 chunks. Module structure: src/clustering/clusterer.py (SemanticClusterer class), src/clustering/initial_load.py, functions/clustering/main.py</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture - Google Cloud + Vertex AI</title>
        <section>Development Guidelines for AI Agents</section>
        <snippet>Infrastructure-as-Code policy: ALL infrastructure changes MUST be managed through Terraform. Use terraform plan and terraform apply. Document changes in architecture docs. Technology research required before implementation.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>PRD V3 - Personal AI Knowledge Base</title>
        <section>Data Flows - Batch Processing Pipeline</section>
        <snippet>Step 5: Cluster & Link → Firestore links + Cloud Storage graph.json. Clustering happens after Knowledge Cards generation in the daily batch pipeline.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/clustering/clusterer.py</path>
        <kind>module</kind>
        <symbol>SemanticClusterer</symbol>
        <lines>1-200</lines>
        <reason>Core clustering class. Has fit_predict() for initial clustering with UMAP (768D → 5D). Need to add transform_and_assign() method for delta clustering using stored UMAP model.</reason>
      </artifact>
      <artifact>
        <path>src/clustering/initial_load.py</path>
        <kind>script</kind>
        <symbol>main</symbol>
        <lines>1-300</lines>
        <reason>Initial clustering script. Currently runs UMAP + HDBSCAN but doesn't save UMAP model. Need to add UMAP model persistence to Cloud Storage after clustering.</reason>
      </artifact>
      <artifact>
        <path>functions/clustering/main.py</path>
        <kind>cloud_function</kind>
        <symbol>clustering_handler</symbol>
        <lines>1-300</lines>
        <reason>Delta clustering Cloud Function. Currently uses 768D cosine distance. Need to load UMAP model and use transform_and_assign() with 5D centroids.</reason>
      </artifact>
      <artifact>
        <path>terraform/clustering.tf</path>
        <kind>infrastructure</kind>
        <symbol>google_cloudfunctions2_function.clustering</symbol>
        <lines>1-100</lines>
        <reason>Terraform config for clustering Cloud Function. Need to add UMAP_MODEL_PATH environment variable.</reason>
      </artifact>
      <artifact>
        <path>src/clustering/cluster_metadata.py</path>
        <kind>module</kind>
        <symbol>update_cluster_metadata</symbol>
        <lines>1-200</lines>
        <reason>Cluster metadata management. May need updates to handle both 768D and 5D centroids.</reason>
      </artifact>
    </code>
    <dependencies>
      <python>
        <package name="umap-learn" version=">=0.5.5">Already installed from Story 2.2</package>
        <package name="scikit-learn" version=">=1.3.0">Already installed from Story 2.2</package>
        <package name="numpy" version=">=1.24.0">Already installed</package>
        <package name="google-cloud-storage" version=">=2.10.0">Already installed, needed for UMAP model storage</package>
        <package name="google-cloud-firestore" version=">=2.16.0">Already installed</package>
      </python>
    </dependencies>
  </artifacts>

  <constraints>
- **Infrastructure-as-Code Policy**: ALL infrastructure changes MUST use Terraform (no gcloud create/update/delete commands). Use terraform plan and terraform apply workflow.
- **UMAP Model Versioning**: Store UMAP version/date in cluster metadata to detect model drift
- **Backward Compatibility**: Keep 768D centroids as reference during migration, add 5D centroids as active
- **Cloud Function Caching**: UMAP model must be cached in global scope to survive multiple invocations
- **Performance Target**: Delta processing must complete in <5 seconds (AC #7)
- **Testing Standards**: Unit tests for core logic, integration tests for Cloud Storage + Firestore operations
- **Code Reuse**: Eliminate duplication between initial_load and Cloud Function by sharing clusterer module
  </constraints>

  <interfaces>
    <interface>
      <name>SemanticClusterer.transform_and_assign</name>
      <kind>method</kind>
      <signature>transform_and_assign(new_embeddings: np.ndarray, cluster_centroids_5d: np.ndarray, cluster_labels: np.ndarray) -> np.ndarray</signature>
      <path>src/clustering/clusterer.py</path>
      <reason>New method to transform 768D embeddings to 5D using stored UMAP model and assign to nearest centroids</reason>
    </interface>
    <interface>
      <name>Cloud Storage UMAP Model</name>
      <kind>storage</kind>
      <signature>gs://kx-hub-pipeline/models/umap_model.pkl</signature>
      <path>Cloud Storage bucket</path>
      <reason>Pickled UMAP model for consistent transform in both initial and delta clustering</reason>
    </interface>
    <interface>
      <name>Firestore clusters collection schema</name>
      <kind>firestore_schema</kind>
      <signature>{ centroid_768d: Vector, centroid_5d: Vector, umap_version: string }</signature>
      <path>Firestore collection: clusters</path>
      <reason>Extended schema to support both 768D (reference) and 5D (active) centroids</reason>
    </interface>
    <interface>
      <name>Clustering Cloud Function HTTP API</name>
      <kind>http_endpoint</kind>
      <signature>POST /clustering-function { chunk_ids: string[], run_id: string }</signature>
      <path>functions/clustering/main.py</path>
      <reason>Existing Cloud Function API. Implementation changes to use UMAP but API remains same.</reason>
    </interface>
  </interfaces>
  <tests>
    <standards>
Use unittest framework with unittest.mock for mocking external dependencies. Test structure: setUp() for fixtures, test methods named test_*. Synthetic embeddings for clustering tests (groups of similar vectors). Mock Firestore and Cloud Storage clients. Run tests with: python3 -m unittest discover -s tests
    </standards>
    <locations>
tests/test_clusterer.py - Unit tests for clustering algorithms
tests/test_integration_clustering.py - Integration tests for Firestore/Cloud Storage
    </locations>
    <ideas>
AC #1 (UMAP model persistence):
- Unit test: Save UMAP model to Cloud Storage (mocked bucket.blob().upload_from_string())
- Unit test: Load UMAP model from Cloud Storage and verify transform consistency
- Integration test: End-to-end save/load with real Cloud Storage (test bucket)

AC #3 (transform_and_assign method):
- Unit test: Transform 10 new 768D embeddings to 5D using mock UMAP model
- Unit test: Assign transformed embeddings to nearest 5D centroids
- Unit test: Error handling when UMAP model not fitted
- Unit test: Verify euclidean distance used (not cosine)

AC #4 (Cloud Function uses UMAP):
- Integration test: Deploy test Cloud Function with UMAP loading
- Integration test: Verify UMAP model cached in global scope (multiple invocations)
- Integration test: Submit 10 new chunks, verify 5D transform used

AC #6 (UMAP consistency):
- Integration test: Cluster 50 chunks via initial_load with UMAP saving
- Integration test: Add 10 chunks via Cloud Function delta processing
- Integration test: Verify assignments use same UMAP space (compare cluster IDs)

AC #7 (Performance <5 seconds):
- Performance test: Measure delta processing time for 10 chunks
- Performance test: Measure UMAP model load time (cold start)
- Performance test: Verify caching improves subsequent invocations
    </ideas>
  </tests>
</story-context>
