# Story 2.3: Clustering Consistency Fix

## Status: PLANNED
**Epic:** 2 - AI-Powered Knowledge Processing
**Dependencies:** Story 2.2 (Semantic Clustering)
**Priority:** HIGH (Critical architectural fix)

---

## Problem Statement

### Inconsistency Discovered

After implementing UMAP + HDBSCAN in Story 2.2, we discovered that **initial clustering** and **delta clustering** use different algorithms:

| Process | Algorithm | Embedding Space | Issue |
|---------|-----------|-----------------|-------|
| **Initial Load** | UMAP (768D → 5D) + HDBSCAN | 5D UMAP-reduced | ✅ Optimal, research-backed |
| **Delta (Cloud Function)** | Cosine nearest neighbor | 768D original | ❌ Inconsistent, less accurate |

### Root Cause

The Cloud Function was deployed **before UMAP implementation** and uses a simplified centroid-based approach:

```python
# functions/clustering/main.py:202
# ❌ Problem: Uses 768D embeddings directly
distances = cosine_distances(new_embeddings, existing_embeddings)
```

**Centroids are stored as 768D means**, not UMAP-reduced representations.

### Impact

1. **Accuracy degradation**: New chunks assigned in different space than initial clusters
2. **Code duplication**: Initial load logic in `src/clustering/`, delta logic in `functions/clustering/`
3. **Maintenance burden**: Changes to clustering must be applied in two places
4. **Inconsistent results**: Same chunk might be assigned to different clusters depending on when it's processed

---

## Solution Architecture

### Core Principle: Single Source of Truth

Move all clustering logic to a **shared module** used by both initial load and Cloud Function.

### New Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                  SHARED CLUSTERING MODULE                        │
│                 (src/clustering/clusterer.py)                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────────────────────────────────────┐      │
│  │  fit_predict() - Initial Clustering                  │      │
│  │  • UMAP: 768D → 5D                                   │      │
│  │  • HDBSCAN: Density clustering                       │      │
│  │  • Store UMAP model & 5D centroids                   │      │
│  └──────────────────────────────────────────────────────┘      │
│                                                                  │
│  ┌──────────────────────────────────────────────────────┐      │
│  │  transform_and_assign() - Delta Clustering           │      │
│  │  • Load stored UMAP model                            │      │
│  │  • Transform new chunks: 768D → 5D                   │      │
│  │  • Assign to nearest 5D centroid                     │      │
│  └──────────────────────────────────────────────────────┘      │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
         ▲                                    ▲
         │                                    │
         │                                    │
    ┌────┴─────┐                      ┌──────┴──────┐
    │ Initial  │                      │   Cloud     │
    │  Load    │                      │  Function   │
    │ Script   │                      │   (Delta)   │
    └──────────┘                      └─────────────┘
```

### Key Changes

1. **Store UMAP model** in Firestore or Cloud Storage
2. **Store 5D centroids** instead of 768D centroids
3. **Transform new chunks** using stored UMAP model before assignment
4. **Shared code path** for both initial and delta

---

## Technical Implementation

### 1. UMAP Model Persistence

**Option A: Pickle to Cloud Storage**
```python
# After initial clustering
import pickle
umap_model = clusterer.umap_model
pickle.dump(umap_model, open('umap_model.pkl', 'wb'))
# Upload to gs://kx-hub-pipeline/models/umap_model.pkl
```

**Option B: UMAP Parameters + State**
Store UMAP parameters and fitted state separately (more portable)

**Recommendation:** Use pickle for simplicity, stored in Cloud Storage

### 2. Update Cluster Metadata

**Current centroid storage (768D):**
```javascript
{
  "centroid": Vector([...768 dimensions...])  // ❌ Original space
}
```

**New centroid storage (5D):**
```javascript
{
  "centroid_768d": Vector([...768 dimensions...]),  // Keep for reference
  "centroid_5d": Vector([...5 dimensions...]),      // ✅ UMAP-reduced
  "umap_version": "2025-11-02"
}
```

### 3. Refactored Clusterer

**Add new method to SemanticClusterer:**

```python
def transform_and_assign(
    self,
    new_embeddings: np.ndarray,
    cluster_centroids_5d: np.ndarray,
    cluster_labels: np.ndarray
) -> np.ndarray:
    """
    Transform new embeddings with UMAP and assign to nearest centroids.

    Requires:
    - self.umap_model must be fitted (loaded from storage)
    - cluster_centroids_5d in UMAP-reduced space

    Args:
        new_embeddings: New 768D embeddings
        cluster_centroids_5d: Existing cluster centroids in 5D UMAP space
        cluster_labels: Labels for each centroid

    Returns:
        Cluster labels for new embeddings
    """
    if self.umap_model is None:
        raise ValueError("UMAP model not fitted. Load from storage first.")

    # Transform new embeddings to 5D UMAP space
    logger.info(f"Transforming {len(new_embeddings)} embeddings: 768D → 5D...")
    new_embeddings_5d = self.umap_model.transform(new_embeddings)

    # Compute euclidean distance in 5D space
    from sklearn.metrics.pairwise import euclidean_distances
    distances = euclidean_distances(new_embeddings_5d, cluster_centroids_5d)

    # Assign to nearest centroid
    nearest_indices = np.argmin(distances, axis=1)
    new_labels = cluster_labels[nearest_indices]

    return new_labels
```

### 4. Cloud Function Update

**New delta clustering flow:**

```python
# Step 1: Load UMAP model from Cloud Storage
logger.info("Loading UMAP model from Cloud Storage...")
bucket = storage_client.bucket('kx-hub-pipeline')
blob = bucket.blob('models/umap_model.pkl')
umap_model_bytes = blob.download_as_bytes()
umap_model = pickle.loads(umap_model_bytes)

# Step 2: Load cluster centroids (5D, not 768D!)
centroid_embeddings_5d, centroid_labels, _ = load_cluster_centroids_5d(db)

# Step 3: Initialize clusterer with loaded UMAP model
clusterer = SemanticClusterer()
clusterer.umap_model = umap_model
clusterer.use_umap = True

# Step 4: Transform and assign
new_labels = clusterer.transform_and_assign(
    new_embeddings_768d,
    centroid_embeddings_5d,
    centroid_labels
)
```

---

## Migration Plan

### Phase 1: Update Initial Load

1. **Modify `src/clustering/initial_load.py`**:
   - After clustering, save UMAP model to Cloud Storage
   - Compute and store 5D centroids in Firestore

2. **Run migration script**:
   - Re-cluster all 823 chunks (takes ~2 minutes)
   - Generate UMAP model and 5D centroids
   - Update Firestore `clusters` collection

### Phase 2: Update Cloud Function

1. **Modify `functions/clustering/main.py`**:
   - Load UMAP model from Cloud Storage
   - Load 5D centroids (not 768D)
   - Use `transform_and_assign()` method

2. **Deploy updated Cloud Function**:
   ```bash
   cd terraform
   terraform apply  # Redeploy with new code
   ```

### Phase 3: Verify Consistency

1. **Test delta assignment**:
   - Add test chunk via Cloud Function
   - Compare assignment to manual UMAP + nearest neighbor
   - Verify consistency

2. **Integration tests**:
   - Update test suite to verify UMAP consistency
   - Test UMAP model loading/saving

---

## Data Migration

### Re-cluster All Chunks

Since centroids changed from 768D to 5D, we need to:

1. **Delete existing clusters**:
   ```python
   # Clear old 768D centroids
   clusters = db.collection('clusters').stream()
   for c in clusters:
       c.reference.delete()
   ```

2. **Re-run initial clustering**:
   ```bash
   python3 -m src.clustering.initial_load
   ```
   - Generates new UMAP model
   - Computes 5D centroids
   - Uploads UMAP model to Cloud Storage

3. **Regenerate cluster metadata**:
   ```bash
   python3 -m src.clustering.cluster_metadata
   ```
   - AI names still valid (cluster membership mostly unchanged)
   - May need to regenerate if cluster boundaries shifted significantly

---

## Testing

### Unit Tests

**Test UMAP consistency:**
```python
def test_umap_transform_consistency():
    """Verify UMAP transform gives consistent results."""
    clusterer = SemanticClusterer(use_umap=True)

    # Fit on initial data
    embeddings = np.random.randn(100, 768)
    clusterer.fit_predict(embeddings)

    # Transform new data
    new_embeddings = np.random.randn(10, 768)
    transformed = clusterer.umap_model.transform(new_embeddings)

    # Verify dimensionality
    assert transformed.shape == (10, 5)
```

**Test delta assignment:**
```python
def test_delta_clustering_uses_umap():
    """Verify delta clustering uses UMAP, not raw embeddings."""
    clusterer = SemanticClusterer(use_umap=True)

    # Mock UMAP model
    clusterer.umap_model = Mock()
    clusterer.umap_model.transform.return_value = np.random.randn(5, 5)

    # Call transform_and_assign
    new_embeddings = np.random.randn(5, 768)
    centroids_5d = np.random.randn(10, 5)
    labels = np.arange(10)

    result = clusterer.transform_and_assign(
        new_embeddings, centroids_5d, labels
    )

    # Verify UMAP transform was called
    clusterer.umap_model.transform.assert_called_once()
```

### Integration Tests

1. **End-to-end consistency test**:
   - Cluster 100 chunks via initial load
   - Add 10 chunks via Cloud Function
   - Verify assignments are in same UMAP space

2. **Model persistence test**:
   - Save UMAP model to Cloud Storage
   - Load in Cloud Function
   - Transform test embeddings
   - Verify output matches original UMAP model

---

## Performance Considerations

### UMAP Transform Performance

- **UMAP fit**: ~3.9 seconds for 823 embeddings (initial load)
- **UMAP transform**: ~0.1 seconds for 10 embeddings (delta)
- **Storage**: UMAP model ~50KB (pickle)

### Delta Processing Timeline

**Before (768D cosine):** ~7 seconds
**After (UMAP + 5D euclidean):**
- Load UMAP model: ~0.2 seconds
- Transform embeddings: ~0.1 seconds
- Compute distances: ~0.05 seconds
- Firestore updates: ~1 second
- **Total: ~1.4 seconds** ✅ **Even faster!**

---

## Storage Requirements

### Cloud Storage

**New files in `gs://kx-hub-pipeline/models/`:**
- `umap_model.pkl`: ~50KB (UMAP fitted model)
- `umap_metadata.json`: Metadata (version, date, parameters)

**Cost:** < $0.001/month (negligible)

### Firestore

**Clusters collection changes:**
- **Before**: 38 clusters × 768D centroid = ~230KB
- **After**: 38 clusters × (768D + 5D) centroid = ~240KB
- **Delta**: +10KB (negligible)

---

## Acceptance Criteria

- [ ] UMAP model saved to Cloud Storage after initial clustering
- [ ] Cluster centroids stored in both 768D (reference) and 5D (active)
- [ ] `transform_and_assign()` method implemented and tested
- [ ] Cloud Function uses UMAP transform for new chunks
- [ ] All 823 chunks re-clustered with new 5D centroid approach
- [ ] Integration tests verify UMAP consistency between initial and delta
- [ ] Delta processing completes in < 5 seconds (faster than before)
- [ ] No code duplication between initial load and Cloud Function
- [ ] Documentation updated with architecture changes

---

## Risks and Mitigations

### Risk 1: UMAP Model Drift

**Risk:** If initial clustering is re-run, UMAP model changes, invalidating old centroids

**Mitigation:**
- Version UMAP models (`umap_model_v1.pkl`, `umap_model_v2.pkl`)
- Store version in cluster metadata
- Cloud Function checks version compatibility

### Risk 2: Storage Performance

**Risk:** Loading UMAP model from Cloud Storage adds latency

**Mitigation:**
- Cache UMAP model in Cloud Function memory (survives across invocations)
- Model is small (~50KB), loads in ~200ms
- Net performance improvement due to 5D distance computation

### Risk 3: Migration Downtime

**Risk:** Re-clustering all chunks causes temporary inconsistency

**Mitigation:**
- Migration is quick (~2 minutes)
- Cloud Function can be disabled during migration
- Worst case: 10 chunks assigned to old clusters (re-run daily pipeline)

---

## Cost Impact

### One-time Migration

- Re-cluster 823 chunks: ~$0.003 (Firestore reads/writes)
- Regenerate cluster metadata: ~$0.01 (Gemini API)
- **Total: ~$0.013**

### Ongoing Costs

- Cloud Storage for UMAP model: < $0.001/month
- No change to Cloud Function costs (faster execution)
- **Total delta: +$0.001/month** (negligible)

---

## Future Enhancements

### 1. Incremental UMAP Updates

Instead of full re-clustering, use UMAP's incremental learning:
- Add new chunks to existing UMAP model
- Update affected cluster boundaries
- More efficient for large datasets

### 2. Multi-Model Support

Store multiple UMAP models for different use cases:
- Fine-grained clustering (5D)
- Coarse clustering (2D for visualization)
- Domain-specific UMAP models

### 3. A/B Testing

Compare centroid-768D vs centroid-5D assignments:
- Track assignment differences
- Measure cluster cohesion improvements
- Quantify accuracy gains

---

## References

- [UMAP Documentation: Transform](https://umap-learn.readthedocs.io/en/latest/transform.html)
- [Scikit-learn Model Persistence](https://scikit-learn.org/stable/model_persistence.html)
- [Cloud Functions Best Practices: Caching](https://cloud.google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations)

---

**Story 2.3 prepared for implementation**
**Ready for review and approval**
