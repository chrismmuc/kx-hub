# Story 3.3: Graph Regeneration on Delta Clustering

## Status: BACKLOG
**Epic:** 3 - Knowledge Graph Enhancement & Optimization
**Dependencies:** Story 2.5 (Storage Permissions), Story 2.3 (Clustering Consistency)
**Priority:** LOW (Nice-to-have, no current visualization feature)
**Story Type:** Enhancement

---

## Problem Statement

After new chunks are added via delta clustering, the knowledge graph (`graph.json`) becomes stale:

- Initial load: `graph.json` generated with all 835 chunks, 37 clusters
- New chunks added: 5-50 chunks added daily via Cloud Function
- Current behavior: `graph.json` NOT updated → visualization shows outdated structure
- Manual workaround: Must re-run `initial_load.py` to refresh graph

**Impact:** Future visualization features will show stale cluster memberships and relationships.

---

## Solution Overview

Add smart graph regeneration to delta clustering Cloud Function:

1. **Smart regeneration**: Only regenerate if data change exceeds threshold (>1% new chunks)
2. **Non-blocking**: Regeneration doesn't delay delta processing
3. **Future-ready**: Incremental updates as Phase 2 enhancement

### When This Matters

- ❌ Not needed yet: Visualization feature (Epic 3) not built
- ✅ Needed later: When visualization is built, graph must be current
- ⏸️ Deferred: Implement when visualization is actually required

---

## Technical Implementation (Future)

### Phase 1: Smart Threshold Regeneration

```python
def should_regenerate_graph(
    num_new_chunks: int,
    total_chunks: int,
    threshold: float = 0.01  # 1% change
) -> bool:
    """Determine if graph should be regenerated."""
    change_ratio = num_new_chunks / total_chunks
    return change_ratio >= threshold
```

**Examples:**
- 5 new chunks / 835 total = 0.6% → Skip regeneration ❌
- 10 new chunks / 835 total = 1.2% → Regenerate ✅
- 50 new chunks / 835 total = 6% → Regenerate ✅

### Phase 2: Incremental Updates (Future Enhancement)

Instead of full regeneration, update only new nodes:

```python
def update_graph_incrementally(
    existing_graph: Dict,
    new_chunks: List[Dict],
    new_labels: np.ndarray
) -> Dict:
    """Add new nodes without full regeneration."""
    # Add new nodes
    for chunk, label in zip(new_chunks, new_labels):
        existing_graph['nodes'].append({
            'id': chunk['id'],
            'cluster_id': f'cluster-{label}',
            'title': chunk['title']
        })

    # Add edges from new nodes to existing nodes
    # (compute edges for new nodes only, not all nodes)

    return existing_graph
```

**Benefits:**
- 10x faster (no need to reload all 835+ chunks)
- Scales to large datasets
- Maintains graph consistency

### Performance Considerations

**Current metrics (835 chunks, 37 clusters):**
- Load all chunks: ~2 seconds
- Compute similarity edges: ~1 second
- Upload to Cloud Storage: ~0.5 seconds
- **Total: ~3.5 seconds**

**With 10,000 chunks:**
- Load all chunks: ~20 seconds
- Compute similarity edges: ~10 seconds
- **Total: ~30 seconds** ⚠️ Too slow for sync

**Threshold for async:**
- < 2,000 chunks: Synchronous ✅
- > 2,000 chunks: Asynchronous (Cloud Tasks) ✅

---

## Acceptance Criteria

- [ ] Smart regeneration threshold implemented (1% default)
- [ ] Graph regeneration skipped <1% changes (most runs)
- [ ] Graph regenerated ≥1% changes (~1-2 times/week)
- [ ] Regeneration completes in <5 seconds for current dataset
- [ ] Non-blocking error handling (graph failure doesn't fail clustering)
- [ ] Environment variable `GRAPH_REGEN_THRESHOLD` configurable
- [ ] Integration tests verify graph updates correctly
- [ ] Monitoring for graph regeneration failures

---

## Why Deferred

This feature was originally planned for Story 2.5 but **deferred because:**

1. **No current use case** - Visualization feature not built yet
   - Epic 3: Knowledge Graph Visualization & Export (not started)
   - Until visualization is built, stale graph.json has no impact on users

2. **Operational cost** - Runs every 1-2 days
   - ~3.5 seconds per run (acceptable)
   - ~$0.01/month compute cost (negligible)
   - But doesn't add value until visualization exists

3. **Story 2.5 priority** - IAM fix is blocking
   - `initial_load.py` cannot run without storage permissions
   - Focus on unblocking + minimal scope = faster delivery
   - Graph regeneration can be added when needed

4. **Pragmatic phasing**
   - Phase 0 (Now): Fix permissions, enable initial load ✅
   - Phase 1 (Later): Add smart regeneration when visualization needed
   - Phase 2 (Future): Incremental updates for large datasets

---

## Implementation Timeline

**When to implement:**
- Start when Epic 3 visualization feature begins
- At that point, graph regeneration becomes critical
- Estimated effort: 4-6 hours for full Phase 1

**Pre-implementation checklist:**
- [ ] Visualization feature (Epic 3) has active development
- [ ] User feedback indicates need for current graphs
- [ ] Performance testing shows <5s regeneration time acceptable

---

## Related Stories

- **Story 2.5**: Storage Permissions Fix (prerequisite, current)
- **Story 2.3**: Clustering Consistency (produces graph.json)
- **Story 2.2**: Semantic Clustering (provides clustering results)
- **Epic 3**: Knowledge Graph Visualization & Export (uses graph.json)

---

## Future Enhancements

### Graph Versioning

Store multiple graph versions for:
- Rollback capability
- A/B testing different graph algorithms
- Historical analysis

```
gs://kx-hub-pipeline/graphs/
  ├── graph-latest.json (symlink)
  ├── graph-2025-11-02.json
  ├── graph-2025-11-01.json
  └── graph-2025-10-31.json
```

### Async Generation with Cloud Tasks

For large datasets (> 2,000 chunks), use Cloud Tasks to prevent timeout:

```python
if total_chunks > 2000:
    # Create Cloud Task for async generation
    task_client = tasks_v2.CloudTasksClient()
    task_client.create_task(parent=queue_path, task=task)
    logger.info("Scheduled async graph generation (large dataset)")
else:
    # Sync generation for small datasets
    generate_graph_sync()
```

---

## Notes

**Scope:**
This story is specifically for **graph regeneration on delta**, not the initial graph generation (that's handled by Story 2.2/2.3).

**Not included:**
- Web UI for graph visualization (Epic 3)
- Graph analytics or insights
- Custom graph layout algorithms

---

**Story 3.2 in BACKLOG**
**Start implementation when Epic 3 visualization begins**
