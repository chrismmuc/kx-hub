# Cloud Workflow for daily batch processing pipeline
# Triggered by Pub/Sub topic: daily-ingest (published by ingest function)
# Orchestrates: normalize → embed (future) → store (future)

main:
  params: [event]
  steps:
    - init:
        assign:
          - project_id: ${sys.get_env("GOOGLE_CLOUD_PROJECT_ID")}
          - region: "europe-west4"
          - message_data: ${event.data.message.data}
          - decoded_message: ${base64.decode(message_data)}

    - parse_pubsub_payload:
        try:
          assign:
            - payload: ${json.decode(decoded_message)}
            - run_id: ${payload.run_id}
        except:
          as: e
          steps:
            - log_parse_error:
                call: sys.log
                args:
                  text: Failed to parse Pub/Sub payload or missing run_id
                  severity: ERROR
            - fail_invalid_payload:
                raise: "INVALID_PUBSUB_PAYLOAD"

    - ensure_run_id:
        switch:
          - condition: ${run_id != null}
            next: log_start
        next: missing_run_id

    - missing_run_id:
        call: sys.log
        args:
          text: Pub/Sub payload missing run_id; aborting workflow
          severity: ERROR
        next: fail_missing_run_id

    - fail_missing_run_id:
        raise: "RUN_ID_MISSING"

    - log_start:
        call: sys.log
        args:
          text: ${"Starting batch pipeline workflow for run_id " + run_id}
          severity: INFO

    # Step 1: Call normalize function to transform JSON → Markdown
    - call_normalize_function:
        try:
          call: http.post
          args:
            url: ${"https://europe-west4-" + project_id + ".cloudfunctions.net/normalize-function"}
            auth:
              type: OIDC
            timeout: 600
            headers:
              Content-Type: application/json
            body:
              run_id: ${run_id}
          result: normalize_result
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 3
          backoff:
            initial_delay: 2
            max_delay: 60
            multiplier: 2
        except:
          as: e
          steps:
            - log_normalize_error:
                call: sys.log
                args:
                  text: Normalize function failed - check logs for details
                  severity: ERROR
            - fail_workflow:
                raise: ${e}

    - log_normalize_success:
        call: sys.log
        args:
          text: Normalize function completed successfully
          severity: INFO

    # Step 2: Call embed function to generate embeddings + store metadata
    - call_embed_function:
        try:
          call: http.post
          args:
            url: ${"https://europe-west4-" + project_id + ".cloudfunctions.net/embed-function"}
            auth:
              type: OIDC
            timeout: 600
            headers:
              Content-Type: application/json
            body:
              run_id: ${run_id}
          result: embed_result
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 3
          backoff:
            initial_delay: 2
            max_delay: 60
            multiplier: 2
        except:
          as: e
          steps:
            - log_embed_error:
                call: sys.log
                args:
                  text: Embed function failed - check logs for details
                  severity: ERROR
            - fail_workflow_embed:
                raise: ${e}

    - log_embed_success:
        call: sys.log
        args:
          text: Embed function completed successfully
          severity: INFO

    # Step 3: Call knowledge cards function to generate AI summaries
    - call_knowledge_cards_function:
        try:
          call: http.post
          args:
            url: ${"https://europe-west4-" + project_id + ".cloudfunctions.net/knowledge-cards-function"}
            auth:
              type: OIDC
            timeout: 1800 # 30 minutes (max allowed for workflow HTTP calls)
            headers:
              Content-Type: application/json
            body:
              run_id: ${run_id}
              batch_size: 100
          result: knowledge_cards_result
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 2
          backoff:
            initial_delay: 5
            max_delay: 120
            multiplier: 2
        except:
          as: e
          steps:
            - log_knowledge_cards_error:
                call: sys.log
                args:
                  text: Knowledge cards function failed - check logs for details
                  severity: ERROR
            - fail_workflow_knowledge_cards:
                raise: ${e}

    - log_knowledge_cards_success:
        call: sys.log
        args:
          text: '${"Knowledge cards function completed: " + string(knowledge_cards_result.body.generated) + " generated, " + string(knowledge_cards_result.body.updated) + " updated"}'
          severity: INFO

    # Extract chunk IDs from embed result for clustering
    - prepare_clustering_payload:
        assign:
          - chunk_ids_for_clustering: ${default(embed_result.body.chunk_ids, [])}

    # Step 4: Call clustering function to assign semantic clusters
    - call_clustering_function:
        try:
          call: http.post
          args:
            url: ${"https://europe-west4-" + project_id + ".cloudfunctions.net/clustering-function"}
            auth:
              type: OIDC
            timeout: 300 # 5 minutes for delta processing
            headers:
              Content-Type: application/json
            body:
              run_id: ${run_id}
              chunk_ids: ${chunk_ids_for_clustering}
          result: clustering_result
        retry:
          predicate: ${http.default_retry_predicate}
          max_retries: 2
          backoff:
            initial_delay: 3
            max_delay: 60
            multiplier: 2
        except:
          as: e
          steps:
            - log_clustering_error:
                call: sys.log
                args:
                  text: Clustering function failed - check logs for details
                  severity: ERROR
            - fail_workflow_clustering:
                raise: ${e}

    - log_clustering_success:
        call: sys.log
        args:
          text: '${"Clustering function completed: " + string(clustering_result.body.clusters_assigned) + " chunks assigned to clusters"}'
          severity: INFO

    # Return success
    - return_success:
        return:
          status: "success"
          normalize_result: ${normalize_result}
          embed_result: ${embed_result}
          knowledge_cards_result: ${knowledge_cards_result}
          clustering_result: ${clustering_result}
